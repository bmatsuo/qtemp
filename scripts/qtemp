#!/usr/bin/env perl

# Use perldoc or option --man to read documentation

our $VERSION = 0.06;

# TODO: add documentation to the .qtemp template format
#   Then add options to view documentation and search the template
#   library.

# Include some core modules.
use strict;
use warnings;
use File::Basename;
use English;
use Carp;
use File::Glob;
use POSIX qw(strftime); 
use Time::Local; 

# Include some CPAN modules;
use Getopt::Euclid qw{ :vars<opt_> };
# I should probably remove Readonly.
use Readonly; 

use App::Qtemp::DirUtils;
use App::Qtemp::SubsTable;
use App::Qtemp::Template;

# Fetch some basic program information
Readonly my $prog_incantation  => $0;
Readonly my $prog_dir          => dirname($0);
Readonly my $prog_name         => basename($0);

########################################################################
# GLOBAL VARIABLES
########################################################################

my $exitcode = 0;   # Program exitcode.
my %opt = %ARGV;    # Command line options/arguments.


########################################################################
# CONSTANTS
########################################################################


# A temporary fix until I figure out MakeMaker (DON'T USE "~")
Readonly my $PREFIX             => '/home/bryan';
Readonly my $BIN_DIR            => $PREFIX.'/bin';
Readonly my $SUPPORT_DIR        => $PREFIX.'/share/qtemp';

# Standard directory for templates accessible to all users.
Readonly my $template_dir       => $SUPPORT_DIR.'/templates';
Readonly my $subs_dir           => $SUPPORT_DIR.'/subs';

# Root directory for user specific template and subs files.
Readonly my $user_qtemp_dir     => '~/.qtemp';
Readonly my $user_templates     => "$user_qtemp_dir/templates";
Readonly my $user_subs          => "$user_qtemp_dir/subs";

# Lists of locations to look for template/subs files.
Readonly my @template_search_locations  => ($user_templates, $template_dir);
Readonly my @subs_search_locations => ($user_subs, $subs_dir);

########################################################################
# MAIN FUNCTION
########################################################################


# Subroutine: main()
# Type: INTERFACE SUB
# Purpose:
#   This subroutine represents the main control thread of the program.
#   Aside from setup of global variables, actual com
# Returns: 
#   Does not return. Exit is called after all other commands.
sub main {
    # Make the substitution table.
    my $sub_table = mk_substitution_table();

    # Find the template.
    my $template = find_and_open_template($opt_template_name);
  
    $template->write_subbed($sub_table, ($opt_output eq '-' ? () : ($opt_output)));

    exit($exitcode);
}

########################################################################
# SUPPORTING SUBROUTINES
########################################################################

# Subroutine: mk_substitution_table()
# Type: INTERNAL UTILITY
# Purpose: 
#   Load defaults, user defined subs files and command line specified
#   substitutions in that order (last loaded is highest priority).
# Returns: A new hash containing all substitutions
sub mk_substitution_table {
    # Create a default substitution table.
    my %def_subs = default_subs($opt{'--date-format'});
    my $st = App::Qtemp::SubsTable->new(substitutions => \%def_subs);

    # Add substitutions from .subs files in ~/.qtemp/subs
    my @sub_files = find_subs_files();
    for my $sub_file (@sub_files) {
        my $file_st = subtable_from($sub_file);
        $st = $st->union($file_st);
    }

    # Add command-line specified substitutions.
    my @opt_subs = @{$opt{'--add-substitution'} || []};
    for my $opt_sub (@opt_subs) { $st->add(@{$opt_sub}); }

    return $st;
}

# Subroutine: default_subs(), default_subs($date_format)
# Type: INTERNAL UTILITY
# Purpose: 
#   Create a hash of default substitutions.
#   If date format is supplied, it will be passed to strftime instead of
#   the default format.
# Returns: Hash
sub default_subs {
    my $date_format = shift || '%D %T';

    # Substitutions which are always defined.
    my %sub_default_constants = (
        'DATE' => strftime($date_format, localtime()), # Current Date
    );

    # Copy to a hash containing entries which are not always defined.
    my %sub_defaults = %sub_default_constants;

    return %sub_defaults;
}

# Subroutine: find_and_open_template($template_name)
# Type: INTERNAL UTILITY
# Purpose: 
#   Find a template file name $template_name in known locations and
#   return an open file handle reading from the template.
# Returns: 
#   Template filehandle Reference open for reading.
sub find_and_open_template {
    my ($tmpl_name) = @_;

    my $path;

    my @search_locations = @template_search_locations;
    my $expected_name = "$tmpl_name.qtemp";

    # look in the possible locations
    SEARCHDIRS:
    for my $search_dir (@search_locations) {
        my @found_templates = grep {m/\. qtemp \z/xms} find_hierarchy($search_dir);
        
        # Construct a possible path of the template.
        my @matching_templates = grep {basename($_) eq $expected_name} @found_templates;
        if (@matching_templates) {
            croak("Found multiple templates with name $expected_name.\n@found_templates\n")
                if (@matching_templates > 1);

            my $match = $matching_templates[0];
            croak("Matching template $match is not readable.") 
                if (!-r $match);
            $path = $match;
            last SEARCHDIRS;
        }
    }

    # Ensure that the template was found.
    croak(
        "Couldn't find template $expected_name in "
            . join(':',@search_locations)
    ) if !defined $path;

    # Read and return the template.
    my $template = read_template_file($path);
    return $template;
}

# Subroutine: find_subs_files()
# Type: INTERNAL UTILITY
# Purpose: 
#   Gather all substitution files to read into the substitution table.
# Returns: List
#   All locatable substition filenames.
sub find_subs_files {
    # Find .qtsubs files in standard search locations
    my @subs_files;
    for my $subs_root (@subs_search_locations) {
        push @subs_files, grep {m/ \.subs \z/xms} find_hierarchy($subs_root);
    }

    # Add any command-line specified files second to give high priority.
    push @subs_files, @{$opt{'--file'}} if defined $opt{'--file'};

    if (!@subs_files) {
        print {\*STDERR} "Didn't find any .subs files.\n";
    }

    # Return the list of subs files.
    return @subs_files;
}

# Finally, kickstart the script
main();

__END__

=head1 NAME

qtemp - quick template generator

=head1 VERSION

This documentation refers to qtemp version 0.06
Originally created on 02/06/10 23:44:17

=head1 USAGE

qtemp [options] <template_name>

=head1 REQUIRED ARGUMENTS

=over

=item <template_name>

Name of template to use (i.e. 'perl' uses template 'perl.qtemp').

=back

=head1 OPTIONS

=over

=item -f <sub_file> | --file [=] <sub_file>

Specify a file with custom substitutions to use.

=for Euclid:
    repeatable
    sub_file.type:  readable

=item -o <output_file> | --output [=] <output_file>

Name of file to print template to (default: '-').
Defines substitution $F mapping to <output_file> if not equal to '-'.

=for Euclid:
    output_file.type:       writable
    output_file.default: '-'

=item -s <pattern>=<sub> | --add-substitution <pattern>=<sub>

Define a substitution to use in the template.

=for Euclid:
    repeatable
    pattern.type: /\w+/
    sub.default: ""

=item -d <date-format> | --date-format [=] <date-format>

Specify the date format to use in the special $D date substitution.

=for Euclid:
    date-format.default: '%D %T'

=item --version

=item --usage

=item --help

=item --man

Print the usual program information

=back

=head1 DESCRIPTION

qtemp is a template managing program. It is currently used generally to
quickly create new scripts (perl, python, ...). It can also be used in
conjunction with vim to insert templates for new functions/subroutines
into a file being editted.

qtemp prints templates either to STDOUT or to a file.

Templates can have substitution variables in them, which allow custom 
information (e.g. filename, creation date, etc.) to be inserted into the 
template at the time of generation.

When templates are written to a file, the template can also specify
commands to execute after writing. This could include running chmod on
script files, or perhaps adding and making an initial commit in a version
control system.

=head1 TEMPLATES

Templates can be added by placing them in any (possibly nested)
subdirectory of a searched template directory.

Templates can contain macro substitutions. A macro substitution is denoted
by a dollar sign ('$') in a template, followed by curly braces ('{','}')
enclosing the macro name. A macro name must start with either an aphabetic
character ('a-z' or 'A-Z') or underscore ('_').  The rest of the 
characters can be either alphanumeric or underscores.  The curly braces 
can be omitted from a macro substitution if the macro name only consists 
of one character (not a recommended practice). Macro substitutions are 
defined in substitution or '.subs' files.  Environment variables can 
also be used as in macro substitutions if a macro with the same name 
was not previously defined.

A single line with only two exclaimation marks denotes the end of the
template. The remaining lines of the template file are treated as a shell
script and executed when the template is written to a file. Pattern
substitution can be performed in the script as well.

=head1 SUBSTITUTIONS

String substitutions to be made in templates can be defined in .subs files
and placed in a searched subs directory.

Substitutions are defined one-per-line in a .subs file.

A substitution definition consists of a single word X (the
substitution name) followed directly by an equal sign. The remaining 
characters on the line of a substitution definition (minus the newline 
character) are used as the substition string for the pattern $X (or ${X}
if X is more than one character).

=head1 SPECIAL SUBSTITUTIONS

There are a number of special substitutions that are defined by default
when qtemp starts execution.

=over

=item
$$

This patern expands to a single dollar sign '$'. This is useful when you
actually want a dollar sign in the template.

=item
$F

When writing the template to a file with the -o option, this pattern
expands to the name of the file being written to.

=item
$D

This pattern will expand to the date in a short form. 

For example: 02/06/10 23:44:17

=back

=head1 EXAMPLES

An example template for a perl program follows:

    #!/usr/bin/perl
    # Filename: $F
    # Author: ${AUTHOR}
    # Created: $D

    sub main {

    }

    exit(main())
    !!
    chmod +x $F

An example substitution file might look like the following:

    NAME=Bryan Matsuo
    EMAIL=bryan.matsuo@gmail.com
    AUTHOR=${NAME} <${EMAIL}>

=head1 AUTHOR

Bryan Matsuo <bryan.matsuo@gmail.com>

=head1 BUGS

=head1 COPYRIGHT & LISCENCE

Copyright (C) 2010 by Bryan Matsuo

This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.10.0 or,
at your option, any later version of Perl 5 you may have available.
